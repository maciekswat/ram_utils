

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ramutils.events &mdash; Ramutils 2.1.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Ramutils 2.1.3 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Ramutils
          

          
          </a>

          
            
            
              <div class="version">
                2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Serializable data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classifier.html">Classifier training, cross validation, and utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../events.html">Event processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pipeline.html">Pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command-line usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc.html">Miscellaneous utilities</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Ramutils</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ramutils.events</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ramutils.events</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A collection of utility functions for loading, cleaning, normalizing, and</span>
<span class="sd">    combining events. There are also a smattering of other helper function for</span>
<span class="sd">    selecting specific types of events. In general, the following steps must be</span>
<span class="sd">    taken to go from raw (on-disk) events to events that can be analyzed:</span>

<span class="sd">        1. Load: Load events from disk into memory</span>
<span class="sd">        2. Clean: Perform standard sets of cleaning operations</span>
<span class="sd">        3. Normalize: Modify fields and values so that events from different</span>
<span class="sd">           experiment can be easily combined</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">numpy.lib.recfunctions</span> <span class="k">import</span> <span class="n">rename_fields</span>

<span class="kn">from</span> <span class="nn">ptsa.data.readers</span> <span class="k">import</span> <span class="n">BaseEventReader</span><span class="p">,</span> <span class="n">JsonIndexReader</span><span class="p">,</span> <span class="n">EEGReader</span>
<span class="kn">from</span> <span class="nn">ramutils.utils</span> <span class="k">import</span> <span class="n">extract_subject_montage</span><span class="p">,</span> <span class="n">get_completed_sessions</span><span class="p">,</span> <span class="n">extract_experiment_series</span>
<span class="kn">from</span> <span class="nn">ramutils.exc</span> <span class="k">import</span> <span class="o">*</span>


<div class="viewcode-block" id="load_events"><a class="viewcode-back" href="../../events.html#ramutils.events.load_events">[docs]</a><span class="k">def</span> <span class="nf">load_events</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;all_events&#39;</span><span class="p">,</span>
                <span class="n">sessions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load events for a specific subject and experiment. If no events are</span>
<span class="sd">    found, an empty recarray with the correct datatypes are returned</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subject: str</span>
<span class="sd">    experiment: str</span>
<span class="sd">    file_type: str</span>
<span class="sd">        The name of the event file to load, i.e. all_events, task_events,</span>
<span class="sd">        math_events, ps4_events. Default is &#39;all_events&#39;</span>
<span class="sd">    sessions: iterable or None</span>
<span class="sd">    rootdir: str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.rec.array</span>
<span class="sd">        A numpy recarray containing all events for the requested subject,</span>
<span class="sd">        experiment, and session(s)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subject_id</span><span class="p">,</span> <span class="n">montage</span> <span class="o">=</span> <span class="n">extract_subject_montage</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span>

    <span class="n">json_reader</span> <span class="o">=</span> <span class="n">JsonIndexReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootdir</span><span class="p">,</span>
                                               <span class="s2">&quot;protocols&quot;</span><span class="p">,</span>
                                               <span class="s2">&quot;r1.json&quot;</span><span class="p">))</span>

    <span class="n">sessions_to_load</span> <span class="o">=</span> <span class="n">sessions</span>
    <span class="k">if</span> <span class="n">sessions_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sessions_to_load</span> <span class="o">=</span> <span class="n">get_completed_sessions</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span>
                                                  <span class="n">rootdir</span><span class="o">=</span><span class="n">rootdir</span><span class="p">)</span>

    <span class="n">event_files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sessions_to_load</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">event_file</span> <span class="o">=</span> <span class="n">json_reader</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">file_type</span><span class="p">,</span>
                                               <span class="n">subject</span><span class="o">=</span><span class="n">subject</span><span class="p">,</span>
                                               <span class="n">experiment</span><span class="o">=</span><span class="n">experiment</span><span class="p">,</span>
                                               <span class="n">session</span><span class="o">=</span><span class="n">session</span><span class="p">)</span>
            <span class="n">event_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_file</span><span class="p">)</span>

        <span class="c1"># If an event file cannot be found for a session, skip that session</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="n">event_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">event_files</span><span class="p">)</span>

    <span class="c1"># Update the paths based on the given root directory. This makes it easier</span>
    <span class="c1"># to run tests and use a mounted file system</span>
    <span class="n">event_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootdir</span><span class="p">,</span> <span class="n">event_file</span><span class="p">)</span> <span class="k">for</span> <span class="n">event_file</span> <span class="ow">in</span>
                   <span class="n">event_files</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">empty_recarray</span> <span class="o">=</span> <span class="n">initialize_empty_event_reccarray</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">empty_recarray</span>

    <span class="c1"># TODO: Make this less ugly to look at</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
        <span class="n">BaseEventReader</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">eliminate_events_with_no_eeg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">event_files</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="clean_events"><a class="viewcode-back" href="../../events.html#ramutils.events.clean_events">[docs]</a><span class="k">def</span> <span class="nf">clean_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_stim_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">all_events</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Peform basic cleaning operations on events such as removing incomplete</span>
<span class="sd">        sessions, negative offset events, and incomplete lists. For FR events,</span>
<span class="sd">        baseline events needs to be found. Events are then normalized so that</span>
<span class="sd">        cross-experiment events can be merged.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>
<span class="sd">        Raw events</span>
<span class="sd">    start_time: int</span>
<span class="sd">    end_time: int</span>
<span class="sd">    duration: int</span>
<span class="sd">    pre: int</span>
<span class="sd">    post: int</span>
<span class="sd">    return_stim_events: bool</span>
<span class="sd">        Indicator for if stim parameters should be returned in addition to the</span>
<span class="sd">        cleaned events</span>
<span class="sd">    all_events: bool</span>
<span class="sd">        Indicates if the data to be cleaned is the all_event.json file. These</span>
<span class="sd">        require a different set of cleaning procedures</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.recarray</span>
<span class="sd">        Cleaned set of events</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function should be called on an experiment by experiment basis and</span>
<span class="sd">    should not be used to clean cross-experiment datasets</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">extract_experiment_from_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">series_num</span> <span class="o">=</span> <span class="n">extract_experiment_series</span><span class="p">(</span><span class="n">experiments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">all_events</span><span class="p">:</span>
        <span class="n">all_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">series_num</span> <span class="o">!=</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">series_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;stim_params&quot;</span> <span class="ow">in</span> <span class="n">all_fields</span><span class="p">:</span>
                <span class="n">all_fields</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;stim_params&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;test&quot;</span> <span class="ow">in</span> <span class="n">all_fields</span><span class="p">:</span>
            <span class="n">all_fields</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
        <span class="n">all_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">all_fields</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">all_events</span>

    <span class="c1"># If you clean &#39;all_events&#39; for joint reports, there will be multiple</span>
    <span class="c1"># experiments, so only check this after determining if you are cleaning</span>
    <span class="c1"># combined events</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Event cleaning can only happen on single-experiment&#39;</span>
                           <span class="s1">&#39; datasets&#39;</span><span class="p">)</span>
    <span class="n">experiment</span> <span class="o">=</span> <span class="n">experiments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">remove_negative_offsets</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="c1"># Only for PS5 do we want to keep the practice list around so we can know</span>
    <span class="c1"># what the baseline mean power was for the session, but we still need to get</span>
    <span class="c1"># rid of the events with -999 for list</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="s1">&#39;PS5&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">experiment</span> <span class="k">for</span> <span class="n">experiment</span> <span class="ow">in</span> <span class="n">experiments</span><span class="p">]):</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">remove_practice_lists</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">list</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">remove_incomplete_lists</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">select_column_subset</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">all_relevant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO: Add remove_repetitions() function to get rid of any recall events</span>
    <span class="c1"># that are just a repeated recall</span>

    <span class="c1"># separate_stim_events is called within the task-specific functions</span>
    <span class="c1"># because the columns to subset differs by task</span>
    <span class="k">if</span> <span class="s2">&quot;FR&quot;</span> <span class="ow">in</span> <span class="n">experiment</span><span class="p">:</span>
        <span class="n">events</span><span class="p">,</span> <span class="n">stim_params</span> <span class="o">=</span> <span class="n">separate_stim_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">insert_baseline_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span>
                                                  <span class="n">start_time</span><span class="p">,</span>
                                                  <span class="n">end_time</span><span class="p">,</span>
                                                  <span class="n">duration</span><span class="p">,</span>
                                                  <span class="n">pre</span><span class="p">,</span>
                                                  <span class="n">post</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">remove_intrusions</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">update_recall_outcome_for_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">normalize_fr_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">elif</span> <span class="s2">&quot;PAL&quot;</span> <span class="ow">in</span> <span class="n">experiment</span><span class="p">:</span>
        <span class="n">events</span><span class="p">,</span> <span class="n">stim_params</span> <span class="o">=</span> <span class="n">separate_stim_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">subset_pal_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">update_pal_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">remove_nonresponses</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">normalize_pal_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">stim_params</span> <span class="o">=</span> <span class="n">initialize_empty_stim_reccarray</span><span class="p">()</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">update_subject</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_stim_events</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">events</span><span class="p">,</span> <span class="n">stim_params</span>

    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="update_subject"><a class="viewcode-back" href="../../events.html#ramutils.events.update_subject">[docs]</a><span class="k">def</span> <span class="nf">update_subject</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Ensure subject field is populated for all events &quot;&quot;&quot;</span>
    <span class="n">subject</span> <span class="o">=</span> <span class="n">extract_subject</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">events</span><span class="o">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">subject</span>
    <span class="k">return</span> <span class="n">events</span></div>


<span class="k">def</span> <span class="nf">normalize_fr_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">combine_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;category_num&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s1">&#39;category_num&#39;</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;phase&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">)</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">select_column_subset</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">events</span>


<div class="viewcode-block" id="normalize_pal_events"><a class="viewcode-back" href="../../events.html#ramutils.events.normalize_pal_events">[docs]</a><span class="k">def</span> <span class="nf">normalize_pal_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform any normalization to PAL event so make the homogeneous enough so</span>
<span class="sd">        that it is trivial to combine with other experiment events.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">rename_correct_to_recalled</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">coerce_study_pair_to_word_event</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;phase&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">)</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s1">&#39;item_name&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s1">&#39;category_num&#39;</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="separate_stim_events"><a class="viewcode-back" href="../../events.html#ramutils.events.separate_stim_events">[docs]</a><span class="k">def</span> <span class="nf">separate_stim_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Separate stim params contained within events structure from the 1-D</span>
<span class="sd">        events. The returned events and stim_params are both 1-dimensional</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pal</span>
<span class="sd">    stim</span>
<span class="sd">    cat</span>
<span class="sd">    events: np.recarray</span>
<span class="sd">        Event structure</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    events: np.reccary</span>
<span class="sd">        1D event structure with stim params removed</span>
<span class="sd">    stim_params: np.recarray</span>
<span class="sd">        2D stim params strsucture</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Short-circuit if no stim params field (non stim experiment) or no events</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;stim_params&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">stim_params</span> <span class="o">=</span> <span class="n">initialize_empty_stim_reccarray</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">events</span><span class="p">,</span> <span class="n">stim_params</span>

    <span class="n">stim_cols</span> <span class="o">=</span> <span class="n">get_required_columns</span><span class="p">(</span><span class="n">pal</span><span class="o">=</span><span class="n">pal</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="n">stim</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="n">cat</span><span class="p">)</span>
    <span class="n">all_cols</span> <span class="o">=</span> <span class="n">get_required_columns</span><span class="p">(</span><span class="n">pal</span><span class="p">)</span>
    <span class="n">all_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="c1"># Historically, some event files do not have a phase field, but we need</span>
    <span class="c1"># it if it is there</span>
    <span class="k">if</span> <span class="s1">&#39;phase&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">stim_cols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span>

    <span class="n">all_fields</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;stim_params&#39;</span><span class="p">)</span>

    <span class="n">stim_params</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">stim_cols</span><span class="p">]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">all_fields</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">events</span><span class="p">,</span> <span class="n">stim_params</span></div>


<div class="viewcode-block" id="rename_correct_to_recalled"><a class="viewcode-back" href="../../events.html#ramutils.events.rename_correct_to_recalled">[docs]</a><span class="k">def</span> <span class="nf">rename_correct_to_recalled</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalizes PAL &quot;recall&quot; event names to match those of FR experiments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.recarray</span>
<span class="sd">        Events with a &#39;recalled&#39; field added to mirror the &#39;correct&#39; field</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">rename_fields</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;correct&#39;</span><span class="p">:</span> <span class="s1">&#39;recalled&#39;</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="add_field"><a class="viewcode-back" href="../../events.html#ramutils.events.add_field">[docs]</a><span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">default_val</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Add field to the recarray</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Converting to a dataframe, adding the field, and reconverting to a</span>
<span class="sd">    recarray because the rec_append_fields function in numpy doesn&#39;t seem to</span>
<span class="sd">    work</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">events_df</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_val</span>
    <span class="n">orig_dtypes</span> <span class="o">=</span> <span class="n">build_dtype_list</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Add the given field and type to dtype list</span>
    <span class="n">orig_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">field_name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">dataframe_to_recarray</span><span class="p">(</span><span class="n">events_df</span><span class="p">,</span> <span class="n">orig_dtypes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="build_dtype_list"><a class="viewcode-back" href="../../events.html#ramutils.events.build_dtype_list">[docs]</a><span class="k">def</span> <span class="nf">build_dtype_list</span><span class="p">(</span><span class="n">dtypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a numpy.dtype object, return a list of tuples in the form</span>
<span class="sd">        (field_name, field_type_string)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">names</span>
    <span class="n">dtype_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)):</span>
        <span class="n">dtype_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dtype_list</span></div>


<div class="viewcode-block" id="dataframe_to_recarray"><a class="viewcode-back" href="../../events.html#ramutils.events.dataframe_to_recarray">[docs]</a><span class="k">def</span> <span class="nf">dataframe_to_recarray</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from dataframe to recarray maintaining the original datatypes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">to_records</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
    <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="remove_negative_offsets"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_negative_offsets">[docs]</a><span class="k">def</span> <span class="nf">remove_negative_offsets</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Remove events with a negative eegoffset &quot;&quot;&quot;</span>
    <span class="n">pos_offset_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;eegoffset&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pos_offset_events</span></div>


<div class="viewcode-block" id="remove_incomplete_lists"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_incomplete_lists">[docs]</a><span class="k">def</span> <span class="nf">remove_incomplete_lists</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove incomplete lists for every session in the given events. Note,</span>
<span class="sd">    there are two ways that this is done in the reporting code, so it is an</span>
<span class="sd">    outstanding item to determine which method is better</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: This needs to be cleaned up and tested</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
    <span class="n">final_event_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="n">sessions</span><span class="p">:</span>
        <span class="n">sess_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)]</span>

        <span class="c1"># partition events into math and task</span>
        <span class="n">math_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">sess_events</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="s1">&#39;PROB&#39;</span><span class="p">])</span>
        <span class="n">task_events</span> <span class="o">=</span> <span class="n">sess_events</span><span class="p">[</span><span class="o">~</span><span class="n">math_mask</span><span class="p">]</span>
        <span class="n">math_events</span> <span class="o">=</span> <span class="n">sess_events</span><span class="p">[</span><span class="n">math_mask</span><span class="p">]</span>
        <span class="n">final_sess_events</span> <span class="o">=</span> <span class="n">task_events</span>
        <span class="n">final_sess_events</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;mstime&#39;</span><span class="p">])</span>

        <span class="c1"># Remove all task events for lists that don&#39;t have a &quot;REC_END&quot; event</span>
        <span class="n">events_by_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">list_group</span><span class="p">])</span> <span class="k">for</span> <span class="n">listno</span><span class="p">,</span>
                                                                <span class="n">list_group</span> <span class="ow">in</span>
                          <span class="n">groupby</span><span class="p">(</span><span class="n">final_sess_events</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">list</span><span class="p">))</span>
        <span class="n">list_has_end</span> <span class="o">=</span> <span class="p">[</span><span class="nb">any</span><span class="p">([</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;REC_END&#39;</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">list_group</span><span class="p">])</span> <span class="ow">or</span>
                        <span class="n">listno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">999</span> <span class="k">for</span> <span class="n">listno</span><span class="p">,</span> <span class="n">list_group</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span>
            <span class="n">final_sess_events</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">list</span><span class="p">)]</span>
        <span class="n">final_sess_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">events_by_list</span><span class="p">,</span> <span class="n">list_has_end</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">])</span>

        <span class="c1"># Re-combine math and task events</span>
        <span class="n">final_sess_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">final_sess_events</span><span class="p">,</span>
                                            <span class="n">math_events</span><span class="p">]))</span>
        <span class="n">final_sess_events</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;mstime&#39;</span><span class="p">])</span>
        <span class="n">final_event_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_sess_events</span><span class="p">)</span>

        <span class="c1"># METHOD #2 (perhaps less accurate?) We need to figure out which one</span>
        <span class="c1"># should be used. Don&#39;t delete for now</span>
        <span class="c1"># try:</span>
        <span class="c1">#     last_list = sess_events[sess_events.type == &#39;REC_END&#39;][-1][&#39;list&#39;]</span>
        <span class="c1">#     final_event_list.append(sess_events[sess_events.list &lt;= last_list])</span>
        <span class="c1"># except IndexError:</span>
        <span class="c1">#     final_event_list.append(sess_events)</span>

    <span class="n">final_events</span> <span class="o">=</span> <span class="n">concatenate_events_for_single_experiment</span><span class="p">(</span><span class="n">final_event_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_events</span></div>


<div class="viewcode-block" id="remove_nonresponses"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_nonresponses">[docs]</a><span class="k">def</span> <span class="nf">remove_nonresponses</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Selects only events that were listed as recalled or not recalled &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">correct</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">correct</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="subset_pal_events"><a class="viewcode-back" href="../../events.html#ramutils.events.subset_pal_events">[docs]</a><span class="k">def</span> <span class="nf">subset_pal_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Only a subset of event types are needed for PAL experiments &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STUDY_PAIR&#39;</span><span class="p">)</span> <span class="o">|</span>
                    <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TEST_PROBE&#39;</span><span class="p">)</span> <span class="o">|</span>
                    <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;PROBE_START&#39;</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="update_recall_outcome_for_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.update_recall_outcome_for_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">update_recall_outcome_for_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manually override the recall outcomes for baseline retrieval and word</span>
<span class="sd">    retrieval events. All baseline retrieval events should be marked as not</span>
<span class="sd">    recalled and all word events in the recall period should be marked as</span>
<span class="sd">    recalled. This assumes that intrusions have already been removed from the</span>
<span class="sd">    given set of events. It exists merely to serve as an extra check on what</span>
<span class="sd">    should already be true in the raw events data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.recarray</span>
<span class="sd">        Events containing updated recall outcomes for retrieval events</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">recalled</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_BASE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">recalled</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="update_pal_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.update_pal_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">update_pal_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create surrogate responses for retrieval period based on PS4/PAL5 design</span>
<span class="sd">    doc. Surrogate responses are created by identifying trials without any</span>
<span class="sd">    responses. For these trials, a new response time is created based on a</span>
<span class="sd">    random draw from the set of response times from actual responses.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Identify the sample rate</span>
    <span class="n">samplerate</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1">#extract_sample_rate(events)</span>

    <span class="c1"># Separate retrieval and non-retrieval events</span>
    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="n">get_pal_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">retrieval_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">retrieval_mask</span><span class="p">]</span>
    <span class="n">nonretrieval_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="o">~</span><span class="n">retrieval_mask</span><span class="p">]</span>

    <span class="n">incorrect_no_response_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">retrieval_events</span><span class="o">.</span><span class="n">RT</span> <span class="o">==</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>
    <span class="n">correct_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">retrieval_events</span><span class="o">.</span><span class="n">correct</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">correct_response_times</span> <span class="o">=</span> <span class="n">retrieval_events</span><span class="p">[</span><span class="n">correct_mask</span><span class="p">]</span><span class="o">.</span><span class="n">RT</span>
    <span class="n">response_time_rand_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                   <span class="nb">len</span><span class="p">(</span><span class="n">correct_response_times</span><span class="p">),</span>
                                                   <span class="nb">sum</span><span class="p">(</span><span class="n">incorrect_no_response_mask</span><span class="p">))</span>
    <span class="n">retrieval_events</span><span class="o">.</span><span class="n">RT</span><span class="p">[</span><span class="n">incorrect_no_response_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_response_times</span><span class="p">[</span>
        <span class="n">response_time_rand_indices</span><span class="p">]</span>
    <span class="n">retrieval_events</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;REC_EVENT&#39;</span>
    <span class="n">retrieval_events</span><span class="o">.</span><span class="n">eegoffset</span> <span class="o">=</span> <span class="n">retrieval_events</span><span class="o">.</span><span class="n">eegoffset</span> <span class="o">+</span> <span class="p">(</span>
        <span class="n">retrieval_events</span><span class="o">.</span><span class="n">RT</span> <span class="o">*</span> <span class="p">(</span><span class="n">samplerate</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="c1"># Staple everything back together</span>
    <span class="n">cleaned_events</span> <span class="o">=</span> <span class="n">concatenate_events_for_single_experiment</span><span class="p">([</span>
        <span class="n">retrieval_events</span><span class="p">,</span> <span class="n">nonretrieval_events</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">cleaned_events</span></div>


<div class="viewcode-block" id="combine_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.combine_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">combine_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine baseline retrieval and actual retrieval events into a single</span>
<span class="sd">        event type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span><span class="o">.</span><span class="n">type</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD&#39;</span><span class="p">)</span> <span class="o">|</span>
                <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_BASE&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;REC_EVENT&#39;</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="coerce_study_pair_to_word_event"><a class="viewcode-back" href="../../events.html#ramutils.events.coerce_study_pair_to_word_event">[docs]</a><span class="k">def</span> <span class="nf">coerce_study_pair_to_word_event</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update STUDY_PAIR events to be WORD events. These are the same event</span>
<span class="sd">    type, but PAL calls them STUDY_PAIR and FR/catFR call them WORD. In the</span>
<span class="sd">    future, it may make more sense to make an update to event creation instead</span>
<span class="sd">    of coercing the event types here.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span><span class="o">.</span><span class="n">type</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STUDY_PAIR&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;WORD&#39;</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="remove_practice_lists"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_practice_lists">[docs]</a><span class="k">def</span> <span class="nf">remove_practice_lists</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Remove practice lists from the set of events &quot;&quot;&quot;</span>
    <span class="n">cleaned_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">list</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cleaned_events</span></div>


<div class="viewcode-block" id="remove_bad_events"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_bad_events">[docs]</a><span class="k">def</span> <span class="nf">remove_bad_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove events whose offset values would result in trying to read data</span>
<span class="sd">    that is out of bounds in the EEG file. Currently, this is done automatically</span>
<span class="sd">    in PTSA when you load the EEG, but to avoid having to catch updated events</span>
<span class="sd">    when reading the EEG, it should be done ahead of time.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="select_column_subset"><a class="viewcode-back" href="../../events.html#ramutils.events.select_column_subset">[docs]</a><span class="k">def</span> <span class="nf">select_column_subset</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">all_relevant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">cat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select only the necessary subset of the fields</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recaarray</span>
<span class="sd">        The set of events to subset from</span>

<span class="sd">    Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    all_relevant: bool</span>
<span class="sd">        A subset that includes all fields that are subsequently used by any</span>
<span class="sd">        of the experiments</span>
<span class="sd">    pal: bool</span>
<span class="sd">        Fields specific to PAL experiments</span>
<span class="sd">    stim: bool</span>
<span class="sd">        Fields specific to stim experiments</span>
<span class="sd">    cat: bool</span>
<span class="sd">        Fields specific to categorical free recall experiments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="n">get_required_columns</span><span class="p">(</span><span class="n">all_relevant</span><span class="o">=</span><span class="n">all_relevant</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="n">pal</span><span class="p">,</span>
                                   <span class="n">stim</span><span class="o">=</span><span class="n">stim</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="n">cat</span><span class="p">)</span>

    <span class="c1"># Not all columns will always be available. This in handled during event</span>
    <span class="c1"># normalization, so column selection should allow for the non-existence</span>
    <span class="c1"># of a desired column</span>
    <span class="n">final_columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">final_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="c1"># Explicitly ask for a copy since a view is returned in numpy 1.13 and later</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">final_columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="get_required_columns"><a class="viewcode-back" href="../../events.html#ramutils.events.get_required_columns">[docs]</a><span class="k">def</span> <span class="nf">get_required_columns</span><span class="p">(</span><span class="n">all_relevant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return baseline mandatory columns based on experiment type</span>

<span class="sd">     Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    all_relevant: bool</span>
<span class="sd">        A subset that includes all fields that are subsequently used by any</span>
<span class="sd">        of the experiments</span>
<span class="sd">    pal: bool</span>
<span class="sd">        Fields specific to PAL experiments</span>
<span class="sd">    stim: bool</span>
<span class="sd">        Fields specific to stim experiments</span>
<span class="sd">    cat: bool</span>
<span class="sd">        Fields specific to categorical free recall experiments</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># FIXME: This would probably be better as just a dictionary</span>
    <span class="k">if</span> <span class="n">all_relevant</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">pal</span><span class="p">,</span> <span class="n">stim</span><span class="p">,</span> <span class="n">cat</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;all cannot be chosen in conjunction with other &#39;</span>
                           <span class="s1">&#39;options&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cat</span> <span class="o">&amp;</span> <span class="n">pal</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;cat and pal cannot be selected at the same time&#39;</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;serialpos&#39;</span><span class="p">,</span> <span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;rectime&#39;</span><span class="p">,</span> <span class="s1">&#39;experiment&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mstime&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;eegoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;recalled&#39;</span><span class="p">,</span> <span class="s1">&#39;intrusion&#39;</span><span class="p">,</span>
        <span class="s1">&#39;montage&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;stim_list&#39;</span><span class="p">,</span> <span class="s1">&#39;eegfile&#39;</span><span class="p">,</span> <span class="s1">&#39;msoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;item_name&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iscorrect&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">all_relevant</span><span class="p">:</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stim_params&#39;</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;correct&#39;</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;category_num&#39;</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;RT&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">columns</span>

    <span class="k">if</span> <span class="n">stim</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;experiment&#39;</span><span class="p">,</span> <span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;stim_list&#39;</span><span class="p">,</span> <span class="s1">&#39;mstime&#39;</span><span class="p">,</span> <span class="s1">&#39;item_name&#39;</span><span class="p">,</span> <span class="s1">&#39;serialpos&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;stim_params&#39;</span><span class="p">,</span> <span class="s1">&#39;recalled&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cat</span><span class="p">:</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;category_num&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pal</span><span class="p">:</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;item_name&#39;</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;recalled&#39;</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;correct&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">columns</span></div>


<div class="viewcode-block" id="initialize_empty_event_reccarray"><a class="viewcode-back" href="../../events.html#ramutils.events.initialize_empty_event_reccarray">[docs]</a><span class="k">def</span> <span class="nf">initialize_empty_event_reccarray</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Utility function for generating a recarray that looks normalized,</span>
<span class="sd">    but is empty.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">empty_recarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;serialpos&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;rectime&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;experiment&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;mstime&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;eegoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;recalled&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;intrusion&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;montage&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;stim_list&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;eegfile&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;msoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;item_name&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;iscorrect&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">empty_recarray</span></div>


<div class="viewcode-block" id="initialize_empty_stim_reccarray"><a class="viewcode-back" href="../../events.html#ramutils.events.initialize_empty_stim_reccarray">[docs]</a><span class="k">def</span> <span class="nf">initialize_empty_stim_reccarray</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Generate empty recarray that mirrors fields in stim_params &quot;&quot;&quot;</span>
    <span class="n">empty_recarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;serialpos&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;experiment&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;mstime&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;recalled&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;stim_list&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i8&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;item_name&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s1">&#39;stim_params&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U256&#39;</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">empty_recarray</span></div>


<div class="viewcode-block" id="insert_baseline_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.insert_baseline_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">insert_baseline_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span>
                                     <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Match recall events to matching baseline periods of failure to recall.</span>
<span class="sd">    This is required for all free recall events, but is not necessary for</span>
<span class="sd">    PAL events, which have a natural baseline/comparison group. Baseline</span>
<span class="sd">    events all begin at least 1000 ms after a vocalization, and end</span>
<span class="sd">    at least 1000 ms before a vocalization. Each recall event is matched,</span>
<span class="sd">    wherever possible, to a valid baseline period from a different list</span>
<span class="sd">    within 3 seconds relative to the onset of the recall period.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : np.recarray</span>
<span class="sd">        The event structure in which to incorporate these baseline periods</span>
<span class="sd">    start_time : int</span>
<span class="sd">        The amount of time to skip at the beginning of the session (ms)</span>
<span class="sd">    end_time : int</span>
<span class="sd">        The amount of time within the recall period to consider (ms)</span>
<span class="sd">    duration: int</span>
<span class="sd">        The length of desired empty epochs</span>
<span class="sd">    pre: int</span>
<span class="sd">        The time before each event to exclude</span>
<span class="sd">    post: int</span>
<span class="sd">        The time after each event to exclude</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.reccarray</span>
<span class="sd">        Events with REC_BASE event types inserted</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">events</span>

    <span class="c1"># TODO: document within code blocks what is actually happening</span>
    <span class="c1"># TODO: Finish cleaning this mess up</span>
    <span class="n">all_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span><span class="p">):</span>
        <span class="n">sess_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)]</span>
        <span class="n">rec_events</span> <span class="o">=</span> <span class="n">select_retrieval_events</span><span class="p">(</span><span class="n">sess_events</span><span class="p">)</span>
        <span class="n">voc_events</span> <span class="o">=</span> <span class="n">select_vocalization_events</span><span class="p">(</span><span class="n">sess_events</span><span class="p">)</span>

        <span class="c1"># Events corresponding to the start of the recall period</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">sess_events</span><span class="p">[(</span><span class="n">sess_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_START&#39;</span><span class="p">)]</span>

        <span class="c1"># Events corresponding to the end of the recall period</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="n">sess_events</span><span class="p">[(</span><span class="n">sess_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_END&#39;</span><span class="p">)]</span>

        <span class="c1"># Times associated with start and stop of recall period</span>
        <span class="n">start_times</span> <span class="o">=</span> <span class="n">starts</span><span class="o">.</span><span class="n">mstime</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">end_times</span> <span class="o">=</span> <span class="n">ends</span><span class="o">.</span><span class="n">mstime</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">rec_lists</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">list</span><span class="p">))</span>

        <span class="c1"># Get list of vocalization times by list if there were any vocalizations</span>
        <span class="c1"># TODO: Pull this into its own function?</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">voc_events</span><span class="p">[(</span><span class="n">voc_events</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="n">lst</span><span class="p">)]</span><span class="o">.</span><span class="n">mstime</span> <span class="k">if</span> <span class="p">(</span>
            <span class="n">voc_events</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="n">lst</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="p">[]</span>
                 <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">rec_lists</span><span class="p">]</span>

        <span class="n">epochs</span> <span class="o">=</span> <span class="n">find_free_time_periods</span><span class="p">(</span><span class="n">times</span><span class="p">,</span>
                                        <span class="n">duration</span><span class="p">,</span>
                                        <span class="n">pre</span><span class="p">,</span>
                                        <span class="n">post</span><span class="p">,</span>
                                        <span class="n">start</span><span class="o">=</span><span class="n">start_times</span><span class="p">,</span>
                                        <span class="n">end</span><span class="o">=</span><span class="n">end_times</span><span class="p">)</span>

        <span class="c1"># FIXME: Wow... could this be any more confusing? Pull out into a</span>
        <span class="c1"># separate function. Times relative to recall start</span>
        <span class="n">rel_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span> <span class="o">-</span> <span class="n">i</span><span class="p">)[(</span><span class="n">t</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">)]</span> <span class="k">for</span>
                     <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span>
                     <span class="nb">zip</span><span class="p">([</span><span class="n">rec_events</span><span class="p">[</span><span class="n">rec_events</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="n">lst</span><span class="p">]</span><span class="o">.</span><span class="n">mstime</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span>
                          <span class="n">rec_lists</span><span class="p">],</span> <span class="n">start_times</span><span class="p">)</span>
                     <span class="p">]</span>
        <span class="n">rel_epochs</span> <span class="o">=</span> <span class="n">epochs</span> <span class="o">-</span> <span class="n">start_times</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">full_match_accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rec_times_list</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rel_times</span><span class="p">):</span>
            <span class="n">is_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">is_match</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">rec_times_list</span><span class="p">:</span>
                <span class="c1"># TODO: possibly parametrize this</span>
                <span class="n">is_match_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">rel_epochs</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3000</span>
                <span class="n">is_match_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">good_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_match_tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">full_match_accum</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">choice_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">good_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
                    <span class="n">choice_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">good_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">choice_position</span><span class="p">],</span>
                                   <span class="n">good_locs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">choice_position</span><span class="p">])</span>
                    <span class="n">full_match_accum</span><span class="p">[</span><span class="n">choice_inds</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">matching_epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="n">full_match_accum</span><span class="p">]</span>
        <span class="n">new_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matching_epochs</span><span class="p">),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">sess_events</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_events</span><span class="p">):</span>
            <span class="n">new_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mstime</span> <span class="o">=</span> <span class="n">matching_epochs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;REC_BASE&#39;</span>

        <span class="n">new_events</span><span class="o">.</span><span class="n">recalled</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">merged_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sess_events</span><span class="p">,</span>
                                                    <span class="n">new_events</span><span class="p">)))</span>
        <span class="n">merged_events</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;mstime&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">merged_events</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_BASE&#39;</span><span class="p">:</span>
                <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">experiment</span> <span class="o">=</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">experiment</span>
                <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">session</span>
                <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">list</span>
                <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">eegfile</span> <span class="o">=</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eegfile</span>
                <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">eegoffset</span> <span class="o">=</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eegoffset</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mstime</span> <span class="o">-</span> <span class="n">merged_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mstime</span><span class="p">)</span>

        <span class="n">all_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged_events</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_events</span><span class="p">))</span></div>


<div class="viewcode-block" id="find_free_time_periods"><a class="viewcode-back" href="../../events.html#ramutils.events.find_free_time_periods">[docs]</a><span class="k">def</span> <span class="nf">find_free_time_periods</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of event times, find epochs between them when nothing is</span>
<span class="sd">    happening.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : list or np.ndarray</span>
<span class="sd">        An iterable of 1-d numpy arrays, each of which indicates event times</span>
<span class="sd">    duration : int</span>
<span class="sd">        The length of the desired empty epochs</span>
<span class="sd">    pre : int</span>
<span class="sd">        the time before each event to exclude</span>
<span class="sd">    post: int</span>
<span class="sd">        The time after each event to exclude</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epoch_array : np.ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Clean this up and add some explanation about what is happening</span>
    <span class="n">n_trials</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">epoch_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trials</span><span class="p">):</span>
        <span class="n">ext_times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ext_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">ext_times</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ext_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_times</span><span class="p">,</span> <span class="p">[</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">pre_times</span> <span class="o">=</span> <span class="n">ext_times</span> <span class="o">-</span> <span class="n">pre</span>
        <span class="n">post_times</span> <span class="o">=</span> <span class="n">ext_times</span> <span class="o">+</span> <span class="n">post</span>
        <span class="n">interval_durations</span> <span class="o">=</span> <span class="n">pre_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">post_times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">free_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">interval_durations</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">trial_epoch_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">free_intervals</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">post_times</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span>
            <span class="n">finish</span> <span class="o">=</span> <span class="n">pre_times</span><span class="p">[</span><span class="n">interval</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">duration</span>
            <span class="n">interval_epoch_times</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">finish</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span><span class="p">))</span>
            <span class="n">trial_epoch_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">interval_epoch_times</span><span class="p">)</span>
        <span class="n">epoch_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trial_epoch_times</span><span class="p">))</span>

    <span class="n">epoch_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_trials</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">epoch_times</span><span class="p">])))</span>
    <span class="n">epoch_array</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch_times</span><span class="p">):</span>
        <span class="n">epoch_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">epoch</span><span class="p">)]</span> <span class="o">=</span> <span class="n">epoch</span>

    <span class="k">return</span> <span class="n">epoch_array</span></div>


<div class="viewcode-block" id="concatenate_events_across_experiments"><a class="viewcode-back" href="../../events.html#ramutils.events.concatenate_events_across_experiments">[docs]</a><span class="k">def</span> <span class="nf">concatenate_events_across_experiments</span><span class="p">(</span><span class="n">event_list</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">cat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate events across different experiment types. To make session</span>
<span class="sd">    numbers unique, 100 is added to the second set of events in event_list,</span>
<span class="sd">    200 to the next set of events, and so on.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event_list: iterable</span>
<span class="sd">        An iterable containing events to be concatenated</span>
<span class="sd">    pal: Bool</span>
<span class="sd">        Indicator for if PAL sessions are included in event_list. This will</span>
<span class="sd">        alter which columns are kept for merging events</span>
<span class="sd">    stim: Bool</span>
<span class="sd">        Indicator for if event_list contains stim sessions. If True,</span>
<span class="sd">        then stim_params field will be kept</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.recarray</span>
<span class="sd">        The combined set of events</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Update sessions to not be in conflict</span>
    <span class="n">session_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final_event_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">events</span> <span class="ow">in</span> <span class="n">event_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span> <span class="c1"># we don&#39;t want to be incrementing if we dont have to</span>
        <span class="n">events</span><span class="o">.</span><span class="n">session</span> <span class="o">+=</span> <span class="n">session_offset</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">select_column_subset</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">pal</span><span class="o">=</span><span class="n">pal</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="n">stim</span><span class="p">,</span> <span class="n">cat</span><span class="o">=</span><span class="n">cat</span><span class="p">)</span>
        <span class="n">final_event_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">session_offset</span> <span class="o">+=</span> <span class="mi">100</span>

    <span class="c1"># In order to combine events, we need have the same fields and types, which</span>
    <span class="c1"># effectively makes the events appear as though coming from the same</span>
    <span class="c1"># experiment</span>
    <span class="n">final_events</span> <span class="o">=</span> <span class="n">concatenate_events_for_single_experiment</span><span class="p">(</span><span class="n">final_event_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_events</span></div>


<div class="viewcode-block" id="concatenate_events_for_single_experiment"><a class="viewcode-back" href="../../events.html#ramutils.events.concatenate_events_for_single_experiment">[docs]</a><span class="k">def</span> <span class="nf">concatenate_events_for_single_experiment</span><span class="p">(</span><span class="n">event_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Combine events that are part of the same experiment</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event_list</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.recarray</span>
<span class="sd">        The flattened set of events</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">event_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="k">for</span> <span class="n">events</span> <span class="ow">in</span> <span class="n">event_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">event_sizes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">empty_events</span> <span class="o">=</span> <span class="n">initialize_empty_event_reccarray</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">empty_events</span>
    <span class="n">final_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">event_list</span><span class="p">))</span>
    <span class="n">final_events</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;mstime&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">final_events</span></div>


<div class="viewcode-block" id="remove_intrusions"><a class="viewcode-back" href="../../events.html#ramutils.events.remove_intrusions">[docs]</a><span class="k">def</span> <span class="nf">remove_intrusions</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select all encoding events that were part of the encoding period or</span>
<span class="sd">    were non-intrusion retrieval events.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">encoding_events_mask</span> <span class="o">=</span> <span class="n">get_encoding_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">retrieval_event_mask</span> <span class="o">=</span> <span class="n">get_fr_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">baseline_retrieval_event_mask</span> <span class="o">=</span> <span class="n">get_baseline_retrieval_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">encoding_events_mask</span> <span class="o">|</span>
            <span class="n">retrieval_event_mask</span> <span class="o">|</span>
            <span class="n">baseline_retrieval_event_mask</span><span class="p">)</span>

    <span class="n">filtered_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="select_word_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_word_events">[docs]</a><span class="k">def</span> <span class="nf">select_word_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">encoding_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Filter out any non-word events</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>
<span class="sd">    encoding_only: bool</span>
<span class="sd">        Flag for whether retrieval events should be included</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">get_word_event_mask</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">encoding_only</span><span class="o">=</span><span class="n">encoding_only</span><span class="p">)</span>
    <span class="n">filtered_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_events</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="get_word_event_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_word_event_mask">[docs]</a><span class="k">def</span> <span class="nf">get_word_event_mask</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">encoding_only</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get a mask identify word events. If encoding_only, then retrieval</span>
<span class="sd">    events will not be counted &quot;&quot;&quot;</span>
    <span class="n">encoding_events_mask</span> <span class="o">=</span> <span class="n">get_encoding_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">retrieval_event_mask</span> <span class="o">=</span> <span class="n">get_all_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">encoding_only</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">encoding_events_mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">encoding_events_mask</span> <span class="o">|</span> <span class="n">retrieval_event_mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="extract_event_metadata"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_event_metadata">[docs]</a><span class="k">def</span> <span class="nf">extract_event_metadata</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract the subject, experiment(s), and session(s) associated with an</span>
<span class="sd">    event structure &quot;&quot;&quot;</span>
    <span class="n">subject</span> <span class="o">=</span> <span class="n">extract_subject</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">extract_experiment_from_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">experiment</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="n">extract_sessions</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subject</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span> <span class="n">sessions</span></div>


<div class="viewcode-block" id="extract_subject"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_subject">[docs]</a><span class="k">def</span> <span class="nf">extract_subject</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract subject identifier from events &quot;&quot;&quot;</span>
    <span class="n">subjects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">subject</span> <span class="o">!=</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">subject</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subjects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;There should only be one subject in an event &#39;</span>
                           <span class="s1">&#39;recarray&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subjects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subject</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">subject</span> <span class="o">=</span> <span class="n">subjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">subject</span></div>


<div class="viewcode-block" id="extract_experiment_from_events"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_experiment_from_events">[docs]</a><span class="k">def</span> <span class="nf">extract_experiment_from_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Given a set of events, return a list of unique experiments contained</span>
<span class="sd">        within</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Experiment field can be blank, so make sure to not include that in the</span>
    <span class="c1"># final list</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">experiment</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">experiment</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Handle the case of empty events being passed</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">experiments</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">experiments</span></div>


<div class="viewcode-block" id="extract_sessions"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_sessions">[docs]</a><span class="k">def</span> <span class="nf">extract_sessions</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a list of sessions contained within the events structure&quot;&quot;&quot;</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sess</span><span class="p">)</span> <span class="k">for</span> <span class="n">sess</span> <span class="ow">in</span> <span class="n">sessions</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sessions</span></div>


<div class="viewcode-block" id="extract_lists"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_lists">[docs]</a><span class="k">def</span> <span class="nf">extract_lists</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a list of lists contained within the events structure &quot;&quot;&quot;</span>
    <span class="n">lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lists</span></div>


<div class="viewcode-block" id="select_session_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_session_events">[docs]</a><span class="k">def</span> <span class="nf">select_session_events</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select events corresponding to a particular session &quot;&quot;&quot;</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="n">extract_sessions</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">session</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sessions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Session </span><span class="si">{}</span><span class="s1"> not in event structure&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">session</span><span class="p">))</span>

    <span class="n">session_event_mask</span> <span class="o">=</span> <span class="n">get_session_mask</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">session</span><span class="p">)</span>
    <span class="n">session_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">session_event_mask</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">session_events</span></div>


<div class="viewcode-block" id="get_session_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_session_mask">[docs]</a><span class="k">def</span> <span class="nf">get_session_mask</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a mask for if an event belongs to the given session &quot;&quot;&quot;</span>
    <span class="n">session_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">session_mask</span></div>


<div class="viewcode-block" id="select_stim_table_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_stim_table_events">[docs]</a><span class="k">def</span> <span class="nf">select_stim_table_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the events needed to build stim session summaries &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">remove_practice_lists</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">get_stim_table_event_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">stim_table_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">stim_table_events</span></div>


<div class="viewcode-block" id="get_stim_table_event_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_stim_table_event_mask">[docs]</a><span class="k">def</span> <span class="nf">get_stim_table_event_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a mask of events to be included for building stim session</span>
<span class="sd">        summaries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stim_table_phases</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;STIM&#39;</span><span class="p">,</span> <span class="s1">&#39;NON-STIM&#39;</span><span class="p">,</span> <span class="s1">&#39;BASELINE&#39;</span><span class="p">,</span> <span class="s1">&#39;PRACTICE&#39;</span><span class="p">]</span>
    <span class="n">event_type_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">phase</span> <span class="ow">in</span> <span class="n">stim_table_phases</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">event_type_mask</span></div>


<div class="viewcode-block" id="get_stim_list_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_stim_list_mask">[docs]</a><span class="k">def</span> <span class="nf">get_stim_list_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return boolean mask identifying stim lists</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not all items in a stim list will be stimulated. Stimulation will depend</span>
<span class="sd">    on the biomarker at the time of encoding</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stim_list_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">phase</span> <span class="o">==</span> <span class="s1">&#39;STIM&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stim_list_mask</span></div>


<div class="viewcode-block" id="extract_stim_information"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_stim_information">[docs]</a><span class="k">def</span> <span class="nf">extract_stim_information</span><span class="p">(</span><span class="n">all_events</span><span class="p">,</span> <span class="n">task_events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Identify stim items, post stim items, and stimulation parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_events: np.recarray</span>
<span class="sd">        All events with stim_params field</span>
<span class="sd">    task_events: np.recarray</span>
<span class="sd">        Task events used for classifier training/evaluation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_stim_item: list</span>
<span class="sd">        Boolean array matching the length of task events indicating if a</span>
<span class="sd">        word was stimulated</span>
<span class="sd">    is_post_stim_item: list</span>
<span class="sd">        Boolean array matching the length of task_events indicating if a word</span>
<span class="sd">        occured after a stimulated word</span>
<span class="sd">    stim_df: pd.DataFrame</span>
<span class="sd">        Stim parameters used for each stimulation event</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a rather convoluted set of logic. The goal is to match all word</span>
<span class="sd">    encoding events with their associated STIM_ON events, which occur as</span>
<span class="sd">    separate entries in the json event structures.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_events</span><span class="p">)</span>
    <span class="n">is_stim_item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">is_post_stim_item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

    <span class="n">stim_param_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;item_name&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;session&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;list&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;amplitude&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;pulse_freq&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;stim_duration&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;stimAnodeTag&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;stimCathodeTag&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>

    <span class="n">lists</span> <span class="o">=</span> <span class="n">extract_lists</span><span class="p">(</span><span class="n">all_events</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
        <span class="n">lst_events</span> <span class="o">=</span> <span class="n">all_events</span><span class="p">[</span><span class="n">all_events</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="n">lst</span><span class="p">]</span>
        <span class="n">lst_stim_words</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">lst_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">]))</span>
        <span class="n">lst_post_stim_words</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">lst_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">]))</span>

        <span class="c1"># j will track word (task) events, while i tracks all events</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst_events</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">:</span>
                <span class="c1"># Messy logic to find stim items</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_ON&#39;</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD_OFF&#39;</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_ON&#39;</span> <span class="ow">or</span> <span class="p">(</span>
                                    <span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;DISTRACT_START&#39;</span>
                                    <span class="ow">and</span> <span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_ON&#39;</span><span class="p">)))):</span>
                    <span class="n">lst_stim_words</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Identify which post &#39;WORD&#39; event was the &#39;STIM_ON&#39;</span>
                    <span class="c1"># event and use the stored stim params for that event to</span>
                    <span class="c1"># update the stim table</span>
                    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_ON&#39;</span><span class="p">:</span>
                            <span class="c1"># Assign stim params</span>
                            <span class="n">loc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">offset</span>

                            <span class="c1"># Single-site stimulation will have stim_param</span>
                            <span class="c1"># field as a record, while multi-site will be</span>
                            <span class="c1"># ndarray. Coerce everything to ndarray for</span>
                            <span class="c1"># consistency</span>
                            <span class="n">stim_params</span> <span class="o">=</span> <span class="n">lst_events</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">stim_params</span>
                            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stim_params</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                                <span class="n">stim_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stim_params</span><span class="p">])</span>

                            <span class="c1"># TODO: Add location field to stim params by</span>
                            <span class="c1"># looking up the contacts in the pairs metadata</span>
                            <span class="c1"># table, which would need to be passed to this</span>
                            <span class="c1"># function</span>

                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;item_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">item_name</span><span class="p">)</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">stim_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">amplitude</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stim_params</span><span class="p">))]))</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;pulse_freq&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">stim_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">pulse_freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stim_params</span><span class="p">))]))</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;stim_duration&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">stim_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">stim_duration</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stim_params</span><span class="p">))]))</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;stimAnodeTag&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">stim_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">anode_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stim_params</span><span class="p">))]))</span>
                            <span class="n">stim_param_data</span><span class="p">[</span><span class="s1">&#39;stimCathodeTag&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">stim_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">cathode_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stim_params</span><span class="p">))]))</span>
                            <span class="k">break</span>

                <span class="c1"># Messy logic to find post stim items</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_OFF&#39;</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_OFF&#39;</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_OFF&#39;</span> <span class="ow">and</span>
                            <span class="n">lst_events</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD_OFF&#39;</span><span class="p">)):</span>
                    <span class="n">lst_post_stim_words</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># FYI: It should always be the case that the number of word events</span>
        <span class="c1"># from all_events.json is equal to the number of events from</span>
        <span class="c1"># task_events.json. However, when reading the eeg as part of</span>
        <span class="c1"># computing powers, the PTSA EEGReader can elect to remove some</span>
        <span class="c1"># events. If it happens to remove a &#39;WORD&#39; event, then these two</span>
        <span class="c1"># values could differ.</span>
        <span class="n">lst_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_events</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span> <span class="n">lst</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lst_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_stim_words</span><span class="p">):</span>
            <span class="n">new_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">lst_events</span><span class="p">[</span><span class="n">lst_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item_name</span><span class="p">,</span>
                               <span class="n">task_events</span><span class="p">[</span><span class="n">lst_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item_name</span><span class="p">)</span>

            <span class="n">lst_stim_words</span> <span class="o">=</span> <span class="n">lst_stim_words</span><span class="p">[</span><span class="n">new_mask</span><span class="p">]</span>
            <span class="n">lst_post_stim_words</span> <span class="o">=</span> <span class="n">lst_post_stim_words</span><span class="p">[</span><span class="n">new_mask</span><span class="p">]</span>
            <span class="c1"># TODO: Do we need to do this correction for the stim param data</span>
            <span class="c1"># as well?</span>

        <span class="n">is_stim_item</span><span class="p">[</span><span class="n">lst_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst_stim_words</span>
        <span class="n">is_post_stim_item</span><span class="p">[</span><span class="n">lst_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst_post_stim_words</span>

    <span class="n">stim_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">stim_param_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_stim_item</span><span class="p">,</span> <span class="n">is_post_stim_item</span><span class="p">,</span> <span class="n">stim_df</span></div>


<div class="viewcode-block" id="validate_single_experiment"><a class="viewcode-back" href="../../events.html#ramutils.events.validate_single_experiment">[docs]</a><span class="k">def</span> <span class="nf">validate_single_experiment</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Raises an error if more than one experiment is present in the events &quot;&quot;&quot;</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">extract_experiment_from_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TooManyExperimentsError</span><span class="p">(</span><span class="s1">&#39;Expected single experiment in events&#39;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="validate_single_session"><a class="viewcode-back" href="../../events.html#ramutils.events.validate_single_session">[docs]</a><span class="k">def</span> <span class="nf">validate_single_session</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Raises an error if more than one session is present in the events &quot;&quot;&quot;</span>
    <span class="n">sessions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sessions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TooManySessionsError</span><span class="p">(</span><span class="s2">&quot;Expected single session events&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="extract_sample_rate"><a class="viewcode-back" href="../../events.html#ramutils.events.extract_sample_rate">[docs]</a><span class="k">def</span> <span class="nf">extract_sample_rate</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract the samplerate used for the given set of events &quot;&quot;&quot;</span>
    <span class="n">eeg_reader</span> <span class="o">=</span> <span class="n">EEGReader</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">events</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">start_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">eeg</span> <span class="o">=</span> <span class="n">eeg_reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">samplerate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">eeg</span><span class="p">[</span><span class="s1">&#39;samplerate&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">samplerate</span></div>


<div class="viewcode-block" id="select_math_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_math_events">[docs]</a><span class="k">def</span> <span class="nf">select_math_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select math events from a set of events &quot;&quot;&quot;</span>
    <span class="n">math_event_mask</span> <span class="o">=</span> <span class="n">get_math_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">math_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">math_event_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">math_events</span></div>


<div class="viewcode-block" id="get_math_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_math_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_math_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get a boolean array identifying math events &quot;&quot;&quot;</span>
    <span class="n">math_event_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;PROB&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math_event_mask</span></div>


<div class="viewcode-block" id="get_nonstim_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_nonstim_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_nonstim_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get a mask of any non-stim WORD events</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    These events are what is used in post-hoc classifier evaluation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">non_stim_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">phase</span> <span class="o">!=</span> <span class="s1">&#39;STIM&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">non_stim_mask</span></div>


<div class="viewcode-block" id="get_time_between_events"><a class="viewcode-back" href="../../events.html#ramutils.events.get_time_between_events">[docs]</a><span class="k">def</span> <span class="nf">get_time_between_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the time between successive events&quot;&quot;&quot;</span>
    <span class="n">inter_event_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">mstime</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">inter_event_times</span></div>


<div class="viewcode-block" id="select_encoding_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_encoding_events">[docs]</a><span class="k">def</span> <span class="nf">select_encoding_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select only encoding events &quot;&quot;&quot;</span>
    <span class="n">encoding_mask</span> <span class="o">=</span> <span class="n">get_encoding_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">encoding_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">encoding_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">encoding_events</span></div>


<div class="viewcode-block" id="get_encoding_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_encoding_mask">[docs]</a><span class="k">def</span> <span class="nf">get_encoding_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create encoding event mask &quot;&quot;&quot;</span>
    <span class="n">encoding_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;WORD&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">encoding_mask</span></div>


<div class="viewcode-block" id="select_vocalization_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_vocalization_events">[docs]</a><span class="k">def</span> <span class="nf">select_vocalization_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select all vocalization events &quot;&quot;&quot;</span>
    <span class="n">vocalization_mask</span> <span class="o">=</span> <span class="n">get_vocalization_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">vocalization_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">vocalization_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vocalization_events</span></div>


<div class="viewcode-block" id="get_vocalization_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_vocalization_mask">[docs]</a><span class="k">def</span> <span class="nf">get_vocalization_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create mask for vocalization events&quot;&quot;&quot;</span>
    <span class="n">vocalization_mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD&#39;</span><span class="p">)</span> <span class="o">|</span>
                         <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD_VV&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">vocalization_mask</span></div>


<div class="viewcode-block" id="select_baseline_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_baseline_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">select_baseline_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select baseline retrieval events &quot;&quot;&quot;</span>
    <span class="n">baseline_retrieval_mask</span> <span class="o">=</span> <span class="n">get_baseline_retrieval_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">baseline_retrieval_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">baseline_retrieval_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">baseline_retrieval_events</span></div>


<div class="viewcode-block" id="get_baseline_retrieval_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_baseline_retrieval_mask">[docs]</a><span class="k">def</span> <span class="nf">get_baseline_retrieval_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a boolean mask for baseline retrieval events &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_BASE&#39;</span><span class="p">)</span>

    <span class="c1"># No events to mask</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No baseline retrieval events found. Create &quot;</span>
                           <span class="s2">&quot;baseline retrieval events first.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="select_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">select_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select retrieval events. Uses the experiment field in the events to</span>
<span class="sd">    determine how selection should be done since selection differes for PAL</span>
<span class="sd">    and FR/catFR</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>
<span class="sd">        Events to mask</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">experiment</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Retrieval event selection only supports &quot;</span>
                           <span class="s2">&quot;single-experiment datasets&quot;</span><span class="p">)</span>
    <span class="n">experiment</span> <span class="o">=</span> <span class="n">experiments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="s2">&quot;FR&quot;</span> <span class="ow">in</span> <span class="n">experiment</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">get_fr_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="k">elif</span> <span class="s2">&quot;PAL&quot;</span><span class="ow">in</span> <span class="n">experiment</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">get_pal_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="n">retrieval_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">retrieval_events</span></div>


<div class="viewcode-block" id="get_fr_retrieval_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_fr_retrieval_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_fr_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Identify actual retrieval events for FR/catFR experiments&quot;&quot;&quot;</span>
    <span class="c1"># FIXME: Parametrize the inter-event threshold</span>
    <span class="c1"># TODO: Why don&#39;t we actually study this 1000ms threshold to optimize it?</span>
    <span class="n">inter_event_times</span> <span class="o">=</span> <span class="n">get_time_between_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD&#39;</span><span class="p">)</span> <span class="o">&amp;</span>
                      <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">intrusion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                      <span class="p">(</span><span class="n">inter_event_times</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">retrieval_mask</span></div>


<div class="viewcode-block" id="get_pal_retrieval_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_pal_retrieval_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_pal_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Identify retrieval events for PAL experiments &quot;&quot;&quot;</span>
    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TEST_PROBE&#39;</span><span class="p">)</span> <span class="o">|</span>
                      <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;PROBE_START&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">retrieval_mask</span></div>


<div class="viewcode-block" id="select_all_retrieval_events"><a class="viewcode-back" href="../../events.html#ramutils.events.select_all_retrieval_events">[docs]</a><span class="k">def</span> <span class="nf">select_all_retrieval_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select both baseline and actual retrieval events &quot;&quot;&quot;</span>
    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="n">get_all_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">retrieval_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">retrieval_mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">retrieval_events</span></div>


<div class="viewcode-block" id="get_all_retrieval_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_all_retrieval_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_all_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a boolean bask for any retrieval event &quot;&quot;&quot;</span>
    <span class="n">all_retrieval_mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_WORD&#39;</span><span class="p">)</span> <span class="o">|</span>
                          <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_BASE&#39;</span><span class="p">)</span> <span class="o">|</span>
                          <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;REC_EVENT&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">all_retrieval_mask</span></div>


<div class="viewcode-block" id="get_recall_events_mask"><a class="viewcode-back" href="../../events.html#ramutils.events.get_recall_events_mask">[docs]</a><span class="k">def</span> <span class="nf">get_recall_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a boolean mask for any recall events &quot;&quot;&quot;</span>
    <span class="n">recall_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">recalled</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">recall_mask</span></div>


<span class="k">def</span> <span class="nf">get_post_stim_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="n">post_stim_events_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;STIM_OFF&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">post_stim_events_mask</span>


<div class="viewcode-block" id="partition_events"><a class="viewcode-back" href="../../events.html#ramutils.events.partition_events">[docs]</a><span class="k">def</span> <span class="nf">partition_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a given set of events into partitions by experiment class (</span>
<span class="sd">    FR/PAL) and encoding/retrieval</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events: np.recarray</span>
<span class="sd">        Set of events to partition</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list containing all identified partitions to the data</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="n">get_all_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">pal_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">experiment</span> <span class="o">==</span> <span class="s2">&quot;PAL1&quot;</span><span class="p">)</span>
    <span class="n">post_stim_mask</span> <span class="o">=</span> <span class="n">get_post_stim_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="n">fr_encoding</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="o">~</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pal_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">post_stim_mask</span><span class="p">)]</span>
    <span class="n">fr_retrieval</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pal_mask</span><span class="p">)]</span>
    <span class="n">pal_encoding</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="o">~</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="n">pal_mask</span><span class="p">)]</span>
    <span class="n">pal_retrieval</span> <span class="o">=</span> <span class="n">events</span><span class="p">[(</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="n">pal_mask</span><span class="p">)]</span>
    <span class="n">post_stim</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">post_stim_mask</span><span class="p">]</span>

    <span class="c1"># Only add partitions with actual events</span>
    <span class="n">final_partitions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;fr_encoding&#39;</span><span class="p">:</span> <span class="n">fr_encoding</span><span class="p">,</span>
        <span class="s1">&#39;fr_retrieval&#39;</span><span class="p">:</span> <span class="n">fr_retrieval</span><span class="p">,</span>
        <span class="s1">&#39;pal_encoding&#39;</span><span class="p">:</span> <span class="n">pal_encoding</span><span class="p">,</span>
        <span class="s1">&#39;pal_retrieval&#39;</span><span class="p">:</span> <span class="n">pal_retrieval</span><span class="p">,</span>
        <span class="s1">&#39;post_stim&#39;</span><span class="p">:</span> <span class="n">post_stim</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">final_partitions</span></div>


<div class="viewcode-block" id="get_partition_masks"><a class="viewcode-back" href="../../events.html#ramutils.events.get_partition_masks">[docs]</a><span class="k">def</span> <span class="nf">get_partition_masks</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of masks corresponding to the partitions present in the</span>
<span class="sd">        events</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">retrieval_mask</span> <span class="o">=</span> <span class="n">get_all_retrieval_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">pal_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">experiment</span> <span class="o">==</span> <span class="s2">&quot;PAL1&quot;</span><span class="p">)</span>
    <span class="n">post_stim_mask</span> <span class="o">=</span> <span class="n">get_post_stim_events_mask</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>

    <span class="n">fr_encoding</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pal_mask</span><span class="p">)</span>
    <span class="n">fr_retrieval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pal_mask</span><span class="p">)</span>
    <span class="n">pal_encoding</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="n">pal_mask</span><span class="p">)</span>
    <span class="n">pal_retrieval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retrieval_mask</span> <span class="o">&amp;</span> <span class="n">pal_mask</span><span class="p">)</span>
    <span class="n">post_stim</span> <span class="o">=</span> <span class="n">post_stim_mask</span>

    <span class="c1"># Only add partitions with actual events</span>
    <span class="n">partition_masks</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;fr_encoding&#39;</span><span class="p">:</span> <span class="n">fr_encoding</span><span class="p">,</span>
        <span class="s1">&#39;fr_retrieval&#39;</span><span class="p">:</span> <span class="n">fr_retrieval</span><span class="p">,</span>
        <span class="s1">&#39;pal_encoding&#39;</span><span class="p">:</span> <span class="n">pal_encoding</span><span class="p">,</span>
        <span class="s1">&#39;pal_retrieval&#39;</span><span class="p">:</span> <span class="n">pal_retrieval</span><span class="p">,</span>
        <span class="s1">&#39;post_stim&#39;</span><span class="p">:</span> <span class="n">post_stim</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">partition_masks</span></div>


<span class="k">def</span> <span class="nf">get_repetition_ratio_dict</span><span class="p">(</span><span class="n">rootdir</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
    <span class="n">all_repetition_rates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_catfr1_subjects</span> <span class="o">=</span> <span class="n">find_subjects</span><span class="p">(</span><span class="s2">&quot;catFR1&quot;</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="n">rootdir</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">all_catfr1_subjects</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">load_events</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="s2">&quot;catFR1&quot;</span><span class="p">,</span> <span class="n">file_type</span><span class="o">=</span><span class="s1">&#39;task_events&#39;</span><span class="p">,</span>
                             <span class="n">rootdir</span><span class="o">=</span><span class="n">rootdir</span><span class="p">)</span>

        <span class="n">recall_events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">events</span><span class="o">.</span><span class="n">recalled</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sessions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">recall_events</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">recall_events</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>

        <span class="c1"># Initialize single subject repetition rates of shape n_sessions X</span>
        <span class="c1"># n_lists</span>
        <span class="n">repetition_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sessions</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repetition_rates</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
            <span class="n">repetition_rates</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">session</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sessions</span><span class="p">):</span>
            <span class="n">sess_recalls</span> <span class="o">=</span> <span class="n">recall_events</span><span class="p">[</span><span class="n">recall_events</span><span class="o">.</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">]</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sess_recalls</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>
            <span class="n">repetition_rates</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">calculate_repetition_ratio</span><span class="p">(</span><span class="n">sess_recalls</span><span class="p">[</span><span class="n">sess_recalls</span><span class="o">.</span><span class="n">list</span> <span class="o">==</span>
                                                        <span class="n">l</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">]</span>
        <span class="n">all_repetition_rates</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="n">repetition_rates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">all_repetition_rates</span>


<div class="viewcode-block" id="find_subjects"><a class="viewcode-back" href="../../events.html#ramutils.events.find_subjects">[docs]</a><span class="k">def</span> <span class="nf">find_subjects</span><span class="p">(</span><span class="n">experiment</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Identify subjects who completed a given experiment &quot;&quot;&quot;</span>
    <span class="n">json_reader</span> <span class="o">=</span> <span class="n">JsonIndexReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootdir</span><span class="p">,</span>
                                               <span class="s2">&quot;protocols&quot;</span><span class="p">,</span>
                                               <span class="s2">&quot;r1.json&quot;</span><span class="p">))</span>
    <span class="n">subjects</span> <span class="o">=</span> <span class="n">json_reader</span><span class="o">.</span><span class="n">subjects</span><span class="p">(</span><span class="n">experiment</span><span class="o">=</span><span class="n">experiment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subjects</span></div>


<div class="viewcode-block" id="calculate_repetition_ratio"><a class="viewcode-back" href="../../events.html#ramutils.events.calculate_repetition_ratio">[docs]</a><span class="k">def</span> <span class="nf">calculate_repetition_ratio</span><span class="p">(</span><span class="n">recall_events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the repetition ratio for a given list based on the recalled</span>
<span class="sd">        events for that list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_repetition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">recall_events</span><span class="o">.</span><span class="n">category_num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">repetition_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_repetition</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">recall_events</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">repetition_ratio</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'2.1.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>